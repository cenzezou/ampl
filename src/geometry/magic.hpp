#pragma once
#include <array>
#include <cstdint>
#include <Eigen/Core>
namespace morton
{
static constexpr const std::array<uint32_t, 256> MORTON_LUT_X_256 = {
    0x00000000, 0x00000001, 0x00000008, 0x00000009, 0x00000040, 0x00000041, 0x00000048, 0x00000049, 0x00000200,
    0x00000201, 0x00000208, 0x00000209, 0x00000240, 0x00000241, 0x00000248, 0x00000249, 0x00001000, 0x00001001,
    0x00001008, 0x00001009, 0x00001040, 0x00001041, 0x00001048, 0x00001049, 0x00001200, 0x00001201, 0x00001208,
    0x00001209, 0x00001240, 0x00001241, 0x00001248, 0x00001249, 0x00008000, 0x00008001, 0x00008008, 0x00008009,
    0x00008040, 0x00008041, 0x00008048, 0x00008049, 0x00008200, 0x00008201, 0x00008208, 0x00008209, 0x00008240,
    0x00008241, 0x00008248, 0x00008249, 0x00009000, 0x00009001, 0x00009008, 0x00009009, 0x00009040, 0x00009041,
    0x00009048, 0x00009049, 0x00009200, 0x00009201, 0x00009208, 0x00009209, 0x00009240, 0x00009241, 0x00009248,
    0x00009249, 0x00040000, 0x00040001, 0x00040008, 0x00040009, 0x00040040, 0x00040041, 0x00040048, 0x00040049,
    0x00040200, 0x00040201, 0x00040208, 0x00040209, 0x00040240, 0x00040241, 0x00040248, 0x00040249, 0x00041000,
    0x00041001, 0x00041008, 0x00041009, 0x00041040, 0x00041041, 0x00041048, 0x00041049, 0x00041200, 0x00041201,
    0x00041208, 0x00041209, 0x00041240, 0x00041241, 0x00041248, 0x00041249, 0x00048000, 0x00048001, 0x00048008,
    0x00048009, 0x00048040, 0x00048041, 0x00048048, 0x00048049, 0x00048200, 0x00048201, 0x00048208, 0x00048209,
    0x00048240, 0x00048241, 0x00048248, 0x00048249, 0x00049000, 0x00049001, 0x00049008, 0x00049009, 0x00049040,
    0x00049041, 0x00049048, 0x00049049, 0x00049200, 0x00049201, 0x00049208, 0x00049209, 0x00049240, 0x00049241,
    0x00049248, 0x00049249, 0x00200000, 0x00200001, 0x00200008, 0x00200009, 0x00200040, 0x00200041, 0x00200048,
    0x00200049, 0x00200200, 0x00200201, 0x00200208, 0x00200209, 0x00200240, 0x00200241, 0x00200248, 0x00200249,
    0x00201000, 0x00201001, 0x00201008, 0x00201009, 0x00201040, 0x00201041, 0x00201048, 0x00201049, 0x00201200,
    0x00201201, 0x00201208, 0x00201209, 0x00201240, 0x00201241, 0x00201248, 0x00201249, 0x00208000, 0x00208001,
    0x00208008, 0x00208009, 0x00208040, 0x00208041, 0x00208048, 0x00208049, 0x00208200, 0x00208201, 0x00208208,
    0x00208209, 0x00208240, 0x00208241, 0x00208248, 0x00208249, 0x00209000, 0x00209001, 0x00209008, 0x00209009,
    0x00209040, 0x00209041, 0x00209048, 0x00209049, 0x00209200, 0x00209201, 0x00209208, 0x00209209, 0x00209240,
    0x00209241, 0x00209248, 0x00209249, 0x00240000, 0x00240001, 0x00240008, 0x00240009, 0x00240040, 0x00240041,
    0x00240048, 0x00240049, 0x00240200, 0x00240201, 0x00240208, 0x00240209, 0x00240240, 0x00240241, 0x00240248,
    0x00240249, 0x00241000, 0x00241001, 0x00241008, 0x00241009, 0x00241040, 0x00241041, 0x00241048, 0x00241049,
    0x00241200, 0x00241201, 0x00241208, 0x00241209, 0x00241240, 0x00241241, 0x00241248, 0x00241249, 0x00248000,
    0x00248001, 0x00248008, 0x00248009, 0x00248040, 0x00248041, 0x00248048, 0x00248049, 0x00248200, 0x00248201,
    0x00248208, 0x00248209, 0x00248240, 0x00248241, 0x00248248, 0x00248249, 0x00249000, 0x00249001, 0x00249008,
    0x00249009, 0x00249040, 0x00249041, 0x00249048, 0x00249049, 0x00249200, 0x00249201, 0x00249208, 0x00249209,
    0x00249240, 0x00249241, 0x00249248, 0x00249249 };

static constexpr const std::array<uint32_t, 256> MORTON_LUT_Y_256 = {
    0x00000000, 0x00000002, 0x00000010, 0x00000012, 0x00000080, 0x00000082, 0x00000090, 0x00000092, 0x00000400,
    0x00000402, 0x00000410, 0x00000412, 0x00000480, 0x00000482, 0x00000490, 0x00000492, 0x00002000, 0x00002002,
    0x00002010, 0x00002012, 0x00002080, 0x00002082, 0x00002090, 0x00002092, 0x00002400, 0x00002402, 0x00002410,
    0x00002412, 0x00002480, 0x00002482, 0x00002490, 0x00002492, 0x00010000, 0x00010002, 0x00010010, 0x00010012,
    0x00010080, 0x00010082, 0x00010090, 0x00010092, 0x00010400, 0x00010402, 0x00010410, 0x00010412, 0x00010480,
    0x00010482, 0x00010490, 0x00010492, 0x00012000, 0x00012002, 0x00012010, 0x00012012, 0x00012080, 0x00012082,
    0x00012090, 0x00012092, 0x00012400, 0x00012402, 0x00012410, 0x00012412, 0x00012480, 0x00012482, 0x00012490,
    0x00012492, 0x00080000, 0x00080002, 0x00080010, 0x00080012, 0x00080080, 0x00080082, 0x00080090, 0x00080092,
    0x00080400, 0x00080402, 0x00080410, 0x00080412, 0x00080480, 0x00080482, 0x00080490, 0x00080492, 0x00082000,
    0x00082002, 0x00082010, 0x00082012, 0x00082080, 0x00082082, 0x00082090, 0x00082092, 0x00082400, 0x00082402,
    0x00082410, 0x00082412, 0x00082480, 0x00082482, 0x00082490, 0x00082492, 0x00090000, 0x00090002, 0x00090010,
    0x00090012, 0x00090080, 0x00090082, 0x00090090, 0x00090092, 0x00090400, 0x00090402, 0x00090410, 0x00090412,
    0x00090480, 0x00090482, 0x00090490, 0x00090492, 0x00092000, 0x00092002, 0x00092010, 0x00092012, 0x00092080,
    0x00092082, 0x00092090, 0x00092092, 0x00092400, 0x00092402, 0x00092410, 0x00092412, 0x00092480, 0x00092482,
    0x00092490, 0x00092492, 0x00400000, 0x00400002, 0x00400010, 0x00400012, 0x00400080, 0x00400082, 0x00400090,
    0x00400092, 0x00400400, 0x00400402, 0x00400410, 0x00400412, 0x00400480, 0x00400482, 0x00400490, 0x00400492,
    0x00402000, 0x00402002, 0x00402010, 0x00402012, 0x00402080, 0x00402082, 0x00402090, 0x00402092, 0x00402400,
    0x00402402, 0x00402410, 0x00402412, 0x00402480, 0x00402482, 0x00402490, 0x00402492, 0x00410000, 0x00410002,
    0x00410010, 0x00410012, 0x00410080, 0x00410082, 0x00410090, 0x00410092, 0x00410400, 0x00410402, 0x00410410,
    0x00410412, 0x00410480, 0x00410482, 0x00410490, 0x00410492, 0x00412000, 0x00412002, 0x00412010, 0x00412012,
    0x00412080, 0x00412082, 0x00412090, 0x00412092, 0x00412400, 0x00412402, 0x00412410, 0x00412412, 0x00412480,
    0x00412482, 0x00412490, 0x00412492, 0x00480000, 0x00480002, 0x00480010, 0x00480012, 0x00480080, 0x00480082,
    0x00480090, 0x00480092, 0x00480400, 0x00480402, 0x00480410, 0x00480412, 0x00480480, 0x00480482, 0x00480490,
    0x00480492, 0x00482000, 0x00482002, 0x00482010, 0x00482012, 0x00482080, 0x00482082, 0x00482090, 0x00482092,
    0x00482400, 0x00482402, 0x00482410, 0x00482412, 0x00482480, 0x00482482, 0x00482490, 0x00482492, 0x00490000,
    0x00490002, 0x00490010, 0x00490012, 0x00490080, 0x00490082, 0x00490090, 0x00490092, 0x00490400, 0x00490402,
    0x00490410, 0x00490412, 0x00490480, 0x00490482, 0x00490490, 0x00490492, 0x00492000, 0x00492002, 0x00492010,
    0x00492012, 0x00492080, 0x00492082, 0x00492090, 0x00492092, 0x00492400, 0x00492402, 0x00492410, 0x00492412,
    0x00492480, 0x00492482, 0x00492490, 0x00492492 };

static constexpr const std::array<uint32_t, 256> MORTON_LUT_Z_256 = {
    0x00000000, 0x00000004, 0x00000020, 0x00000024, 0x00000100, 0x00000104, 0x00000120, 0x00000124, 0x00000800,
    0x00000804, 0x00000820, 0x00000824, 0x00000900, 0x00000904, 0x00000920, 0x00000924, 0x00004000, 0x00004004,
    0x00004020, 0x00004024, 0x00004100, 0x00004104, 0x00004120, 0x00004124, 0x00004800, 0x00004804, 0x00004820,
    0x00004824, 0x00004900, 0x00004904, 0x00004920, 0x00004924, 0x00020000, 0x00020004, 0x00020020, 0x00020024,
    0x00020100, 0x00020104, 0x00020120, 0x00020124, 0x00020800, 0x00020804, 0x00020820, 0x00020824, 0x00020900,
    0x00020904, 0x00020920, 0x00020924, 0x00024000, 0x00024004, 0x00024020, 0x00024024, 0x00024100, 0x00024104,
    0x00024120, 0x00024124, 0x00024800, 0x00024804, 0x00024820, 0x00024824, 0x00024900, 0x00024904, 0x00024920,
    0x00024924, 0x00100000, 0x00100004, 0x00100020, 0x00100024, 0x00100100, 0x00100104, 0x00100120, 0x00100124,
    0x00100800, 0x00100804, 0x00100820, 0x00100824, 0x00100900, 0x00100904, 0x00100920, 0x00100924, 0x00104000,
    0x00104004, 0x00104020, 0x00104024, 0x00104100, 0x00104104, 0x00104120, 0x00104124, 0x00104800, 0x00104804,
    0x00104820, 0x00104824, 0x00104900, 0x00104904, 0x00104920, 0x00104924, 0x00120000, 0x00120004, 0x00120020,
    0x00120024, 0x00120100, 0x00120104, 0x00120120, 0x00120124, 0x00120800, 0x00120804, 0x00120820, 0x00120824,
    0x00120900, 0x00120904, 0x00120920, 0x00120924, 0x00124000, 0x00124004, 0x00124020, 0x00124024, 0x00124100,
    0x00124104, 0x00124120, 0x00124124, 0x00124800, 0x00124804, 0x00124820, 0x00124824, 0x00124900, 0x00124904,
    0x00124920, 0x00124924, 0x00800000, 0x00800004, 0x00800020, 0x00800024, 0x00800100, 0x00800104, 0x00800120,
    0x00800124, 0x00800800, 0x00800804, 0x00800820, 0x00800824, 0x00800900, 0x00800904, 0x00800920, 0x00800924,
    0x00804000, 0x00804004, 0x00804020, 0x00804024, 0x00804100, 0x00804104, 0x00804120, 0x00804124, 0x00804800,
    0x00804804, 0x00804820, 0x00804824, 0x00804900, 0x00804904, 0x00804920, 0x00804924, 0x00820000, 0x00820004,
    0x00820020, 0x00820024, 0x00820100, 0x00820104, 0x00820120, 0x00820124, 0x00820800, 0x00820804, 0x00820820,
    0x00820824, 0x00820900, 0x00820904, 0x00820920, 0x00820924, 0x00824000, 0x00824004, 0x00824020, 0x00824024,
    0x00824100, 0x00824104, 0x00824120, 0x00824124, 0x00824800, 0x00824804, 0x00824820, 0x00824824, 0x00824900,
    0x00824904, 0x00824920, 0x00824924, 0x00900000, 0x00900004, 0x00900020, 0x00900024, 0x00900100, 0x00900104,
    0x00900120, 0x00900124, 0x00900800, 0x00900804, 0x00900820, 0x00900824, 0x00900900, 0x00900904, 0x00900920,
    0x00900924, 0x00904000, 0x00904004, 0x00904020, 0x00904024, 0x00904100, 0x00904104, 0x00904120, 0x00904124,
    0x00904800, 0x00904804, 0x00904820, 0x00904824, 0x00904900, 0x00904904, 0x00904920, 0x00904924, 0x00920000,
    0x00920004, 0x00920020, 0x00920024, 0x00920100, 0x00920104, 0x00920120, 0x00920124, 0x00920800, 0x00920804,
    0x00920820, 0x00920824, 0x00920900, 0x00920904, 0x00920920, 0x00920924, 0x00924000, 0x00924004, 0x00924020,
    0x00924024, 0x00924100, 0x00924104, 0x00924120, 0x00924124, 0x00924800, 0x00924804, 0x00924820, 0x00924824,
    0x00924900, 0x00924904, 0x00924920, 0x00924924 };

static constexpr const uint32_t MORTON_X_MASK = 0x49249249;
static constexpr const uint32_t MORTON_Y_MASK = 0x92492492;
static constexpr const uint32_t MORTON_Z_MASK = 0x24924924;
static constexpr const uint32_t EBMASK        = 0x000000FF;
constexpr const uint32_t MORTON_FACTOR_256    = 1000;
}  // namespace morton

namespace marching_cube
{
typedef double mc_real;
typedef uint32_t mc_uint;

static constexpr const mc_uint MC_RESERVE_BUFFER_SIZE_VERTEX   = 100000;
static constexpr const mc_uint MC_RESERVE_BUFFER_SIZE_NORMAL   = 100000;
static constexpr const mc_uint MC_RESERVE_BUFFER_SIZE_TRIANGLE = 400000;

static constexpr const std::array<unsigned long long, 256> MC_LUT = {
    0ULL,
    33793ULL,
    36945ULL,
    159668546ULL,
    18961ULL,
    144771090ULL,
    5851666ULL,
    595283255635ULL,
    20913ULL,
    67640146ULL,
    193993474ULL,
    655980856339ULL,
    88782242ULL,
    736732689667ULL,
    797430812739ULL,
    194554754ULL,
    26657ULL,
    104867330ULL,
    136709522ULL,
    298069416227ULL,
    109224258ULL,
    8877909667ULL,
    318136408323ULL,
    1567994331701604ULL,
    189884450ULL,
    350847647843ULL,
    559958167731ULL,
    3256298596865604ULL,
    447393122899ULL,
    651646838401572ULL,
    2538311371089956ULL,
    737032694307ULL,
    29329ULL,
    43484162ULL,
    91358498ULL,
    374810899075ULL,
    158485010ULL,
    178117478419ULL,
    88675058979ULL,
    433581536604804ULL,
    158486962ULL,
    649105605635ULL,
    4866906995ULL,
    3220959471609924ULL,
    649165714851ULL,
    3184943915608436ULL,
    570691368417972ULL,
    595804498035ULL,
    124295042ULL,
    431498018963ULL,
    508238522371ULL,
    91518530ULL,
    318240155763ULL,
    291789778348404ULL,
    1830001131721892ULL,
    375363605923ULL,
    777781811075ULL,
    1136111028516116ULL,
    3097834205243396ULL,
    508001629971ULL,
    2663607373704004ULL,
    680242583802939237ULL,
    333380770766129845ULL,
    179746658ULL,
    42545ULL,
    138437538ULL,
    93365810ULL,
    713842853011ULL,
    73602098ULL,
    69575510115ULL,
    23964357683ULL,
    868078761575828ULL,
    28681778ULL,
    713778574611ULL,
    250912709379ULL,
    2323825233181284ULL,
    302080811955ULL,
    3184439127991172ULL,
    1694042660682596ULL,
    796909779811ULL,
    176306722ULL,
    150327278147ULL,
    619854856867ULL,
    1005252473234484ULL,
    211025400963ULL,
    36712706ULL,
    360743481544788ULL,
    150627258963ULL,
    117482600995ULL,
    1024968212107700ULL,
    2535169275963444ULL,
    4734473194086550421ULL,
    628107696687956ULL,
    9399128243ULL,
    5198438490361643573ULL,
    194220594ULL,
    104474994ULL,
    566996932387ULL,
    427920028243ULL,
    2014821863433780ULL,
    492093858627ULL,
    147361150235284ULL,
    2005882975110676ULL,
    9671606099636618005ULL,
    777701008947ULL,
    3185463219618820ULL,
    482784926917540ULL,
    2900953068249785909ULL,
    1754182023747364ULL,
    4274848857537943333ULL,
    13198752741767688709ULL,
    2015093490989156ULL,
    591272318771ULL,
    2659758091419812ULL,
    1531044293118596ULL,
    298306479155ULL,
    408509245114388ULL,
    210504348563ULL,
    9248164405801223541ULL,
    91321106ULL,
    2660352816454484ULL,
    680170263324308757ULL,
    8333659837799955077ULL,
    482966828984116ULL,
    4274926723105633605ULL,
    3184439197724820ULL,
    192104450ULL,
    15217ULL,
    45937ULL,
    129205250ULL,
    129208402ULL,
    529245952323ULL,
    169097138ULL,
    770695537027ULL,
    382310500883ULL,
    2838550742137652ULL,
    122763026ULL,
    277045793139ULL,
    81608128403ULL,
    1991870397907988ULL,
    362778151475ULL,
    2059003085103236ULL,
    2132572377842852ULL,
    655681091891ULL,
    58419234ULL,
    239280858627ULL,
    529092143139ULL,
    1568257451898804ULL,
    447235128115ULL,
    679678845236084ULL,
    2167161349491220ULL,
    1554184567314086709ULL,
    165479003923ULL,
    1428768988226596ULL,
    977710670185060ULL,
    10550024711307499077ULL,
    1305410032576132ULL,
    11779770265620358997ULL,
    333446212255967269ULL,
    978168444447012ULL,
    162736434ULL,
    35596216627ULL,
    138295313843ULL,
    891861543990356ULL,
    692616541075ULL,
    3151866750863876ULL,
    100103641866564ULL,
    6572336607016932133ULL,
    215036012883ULL,
    726936420696196ULL,
    52433666ULL,
    82160664963ULL,
    2588613720361524ULL,
    5802089162353039525ULL,
    214799000387ULL,
    144876322ULL,
    668013605731ULL,
    110616894681956ULL,
    1601657732871812ULL,
    430945547955ULL,
    3156382366321172ULL,
    7644494644932993285ULL,
    3928124806469601813ULL,
    3155990846772900ULL,
    339991010498708ULL,
    10743689387941597493ULL,
    5103845475ULL,
    105070898ULL,
    3928064910068824213ULL,
    156265010ULL,
    1305138421793636ULL,
    27185ULL,
    195459938ULL,
    567044449971ULL,
    382447549283ULL,
    2175279159592324ULL,
    443529919251ULL,
    195059004769796ULL,
    2165424908404116ULL,
    1554158691063110021ULL,
    504228368803ULL,
    1436350466655236ULL,
    27584723588724ULL,
    1900945754488837749ULL,
    122971970ULL,
    443829749251ULL,
    302601798803ULL,
    108558722ULL,
    724700725875ULL,
    43570095105972ULL,
    2295263717447940ULL,
    2860446751369014181ULL,
    2165106202149444ULL,
    69275726195ULL,
    2860543885641537797ULL,
    2165106320445780ULL,
    2280890014640004ULL,
    11820349930268368933ULL,
    8721082628082003989ULL,
    127050770ULL,
    503707084675ULL,
    122834978ULL,
    2538193642857604ULL,
    10129ULL,
    801441490467ULL,
    2923200302876740ULL,
    1443359556281892ULL,
    2901063790822564949ULL,
    2728339631923524ULL,
    7103874718248233397ULL,
    12775311047932294245ULL,
    95520290ULL,
    2623783208098404ULL,
    1900908618382410757ULL,
    137742672547ULL,
    2323440239468964ULL,
    362478212387ULL,
    727199575803140ULL,
    73425410ULL,
    34337ULL,
    163101314ULL,
    668566030659ULL,
    801204361987ULL,
    73030562ULL,
    591509145619ULL,
    162574594ULL,
    100608342969108ULL,
    5553ULL,
    724147968595ULL,
    1436604830452292ULL,
    176259090ULL,
    42001ULL,
    143955266ULL,
    2385ULL,
    18433ULL,
    0ULL,
};

}  // namespace marching_cube

namespace marching_cube
{
using mc_real = marching_cube::mc_real;
using mc_uint = marching_cube::mc_uint;
typedef Eigen::Vector3<uint32_t> mc_vec3ui;
typedef Eigen::Vector3<int32_t> mc_vec3i;
typedef Eigen::Vector3<mc_real> mc_vec3r;
#define mc_index1d( i, j, k, sx, sy )     ( ( (k)*sy + ( j ) ) * sx + ( i ) )
#define mc_index1dslab( i, j, k, sx, sy ) ( ( ( ( k ) % 2 ) * sy + ( j ) ) * sx + ( i ) )

static inline void compute_edge( mc_vec3ui *slab_inds, mc_real va, mc_real vb, int axis, mc_uint x, mc_uint y,
                                 mc_uint z, const mc_uint &sx, const mc_uint &sy, std::vector<mc_vec3r> &vertices )
{
  if ( ( va < 0.0 ) == ( vb < 0.0 ) )
  {
    return;
  }
  mc_vec3r v( x, y, z );
  v[ axis ] += va / ( va - vb );
  slab_inds[ mc_index1dslab( x, y, z, sx, sy ) ][ axis ] = static_cast<mc_uint>( vertices.size() );
  vertices.push_back( v );
}
static inline void compute_edge( mc_vec3ui *slab_inds, mc_real va, mc_real vb, int axis, mc_uint x, mc_uint y,
                                 mc_uint z, const mc_uint &sx, const mc_uint &sy, std::vector<mc_vec3r> &vertices,
                                 std::vector<mc_vec3r> &normals )
{
  if ( ( va < 0.0 ) == ( vb < 0.0 ) )
  {
    return;
  }
  mc_vec3r v( x, y, z );
  v[ axis ] += va / ( va - vb );
  slab_inds[ mc_index1dslab( x, y, z, sx, sy ) ][ axis ] = static_cast<mc_uint>( vertices.size() );
  vertices.push_back( v );
  normals.push_back( mc_vec3r::Zero() );
}

template <typename REAL>
void marching_cube( const REAL *df, REAL df_offset, mc_uint nx, mc_uint ny, mc_uint nz, std::vector<mc_vec3r> &vertices,
                    std::vector<mc_vec3ui> &indices, std::vector<mc_vec3r> *normals = nullptr )
{
  vertices.reserve( marching_cube::MC_RESERVE_BUFFER_SIZE_VERTEX );
  indices.reserve( marching_cube::MC_RESERVE_BUFFER_SIZE_TRIANGLE );
  if ( normals )
  {
    normals->reserve( marching_cube::MC_RESERVE_BUFFER_SIZE_NORMAL );
  }

  mc_vec3ui *slab_indices              = new mc_vec3ui[ nx * ny * 2 ];
  Eigen::Vector<mc_real, 8> vs         = Eigen::Vector<mc_real, 8>::Zero();
  std::array<mc_uint, 12> edge_indices = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

  const mc_uint &sx = nx;
  const mc_uint &sy = ny;

  const mc_real v_offset = -df_offset;
  // const mc_uint &sz = nz;

  for ( mc_uint z = 0; z < nz - 1; z++ )
  {
    for ( mc_uint y = 0; y < ny - 1; y++ )
    {
      for ( mc_uint x = 0; x < nx - 1; x++ )
      {
        vs[ 0 ] = df[ mc_index1d( x, y, z, sx, sy ) ];
        vs[ 1 ] = df[ mc_index1d( x + 1, y, z, sx, sy ) ];
        vs[ 2 ] = df[ mc_index1d( x, y + 1, z, sx, sy ) ];
        vs[ 3 ] = df[ mc_index1d( x + 1, y + 1, z, sx, sy ) ];
        vs[ 4 ] = df[ mc_index1d( x, y, z + 1, sx, sy ) ];
        vs[ 5 ] = df[ mc_index1d( x + 1, y, z + 1, sx, sy ) ];
        vs[ 6 ] = df[ mc_index1d( x, y + 1, z + 1, sx, sy ) ];
        vs[ 7 ] = df[ mc_index1d( x + 1, y + 1, z + 1, sx, sy ) ];

        vs.array() += v_offset;

        const int which_lut = ( ( vs[ 0 ] < 0 ) << 0 ) | ( ( vs[ 1 ] < 0 ) << 1 ) | ( ( vs[ 2 ] < 0 ) << 2 ) |
                              ( ( vs[ 3 ] < 0 ) << 3 ) | ( ( vs[ 4 ] < 0 ) << 4 ) | ( ( vs[ 5 ] < 0 ) << 5 ) |
                              ( ( vs[ 6 ] < 0 ) << 6 ) | ( ( vs[ 7 ] < 0 ) << 7 );
        if ( which_lut == 0 || which_lut == 255 )
        {
          continue;
        }
        // printf( "%d\n", which_lut );
        if ( y == 0 && z == 0 )
        {
          compute_edge( slab_indices, vs[ 0 ], vs[ 1 ], 0, x, y, z, sx, sy, vertices );
        }
        if ( z == 0 )
        {
          compute_edge( slab_indices, vs[ 2 ], vs[ 3 ], 0, x, y + 1, z, sx, sy, vertices );
        }
        if ( y == 0 )
        {
          compute_edge( slab_indices, vs[ 4 ], vs[ 5 ], 0, x, y, z + 1, sx, sy, vertices );
        }
        compute_edge( slab_indices, vs[ 6 ], vs[ 7 ], 0, x, y + 1, z + 1, sx, sy, vertices );

        if ( x == 0 && z == 0 )
        {
          compute_edge( slab_indices, vs[ 0 ], vs[ 2 ], 1, x, y, z, sx, sy, vertices );
        }
        if ( z == 0 )
        {
          compute_edge( slab_indices, vs[ 1 ], vs[ 3 ], 1, x + 1, y, z, sx, sy, vertices );
        }
        if ( x == 0 )
        {
          compute_edge( slab_indices, vs[ 4 ], vs[ 6 ], 1, x, y, z + 1, sx, sy, vertices );
        }
        compute_edge( slab_indices, vs[ 5 ], vs[ 7 ], 1, x + 1, y, z + 1, sx, sy, vertices );

        if ( x == 0 && y == 0 )
        {
          compute_edge( slab_indices, vs[ 0 ], vs[ 4 ], 2, x, y, z, sx, sy, vertices );
        }
        if ( y == 0 )
        {
          compute_edge( slab_indices, vs[ 1 ], vs[ 5 ], 2, x + 1, y, z, sx, sy, vertices );
        }
        if ( x == 0 )
        {
          compute_edge( slab_indices, vs[ 2 ], vs[ 6 ], 2, x, y + 1, z, sx, sy, vertices );
        }
        compute_edge( slab_indices, vs[ 3 ], vs[ 7 ], 2, x + 1, y + 1, z, sx, sy, vertices );

        edge_indices[ 0 ]  = slab_indices[ mc_index1dslab( x, y, z, sx, sy ) ].x();
        edge_indices[ 1 ]  = slab_indices[ mc_index1dslab( x, y + 1, z, sx, sy ) ].x();
        edge_indices[ 2 ]  = slab_indices[ mc_index1dslab( x, y, z + 1, sx, sy ) ].x();
        edge_indices[ 3 ]  = slab_indices[ mc_index1dslab( x, y + 1, z + 1, sx, sy ) ].x();
        edge_indices[ 4 ]  = slab_indices[ mc_index1dslab( x, y, z, sx, sy ) ].y();
        edge_indices[ 5 ]  = slab_indices[ mc_index1dslab( x + 1, y, z, sx, sy ) ].y();
        edge_indices[ 6 ]  = slab_indices[ mc_index1dslab( x, y, z + 1, sx, sy ) ].y();
        edge_indices[ 7 ]  = slab_indices[ mc_index1dslab( x + 1, y, z + 1, sx, sy ) ].y();
        edge_indices[ 8 ]  = slab_indices[ mc_index1dslab( x, y, z, sx, sy ) ].z();
        edge_indices[ 9 ]  = slab_indices[ mc_index1dslab( x + 1, y, z, sx, sy ) ].z();
        edge_indices[ 10 ] = slab_indices[ mc_index1dslab( x, y + 1, z, sx, sy ) ].z();
        edge_indices[ 11 ] = slab_indices[ mc_index1dslab( x + 1, y + 1, z, sx, sy ) ].z();

        const unsigned long long &config = marching_cube::MC_LUT[ which_lut ];

        const size_t n_triangles = config & 0xF;
        int offset               = 4;
        for ( size_t i = 0; i < n_triangles; i++ )
        {
          const int edge0 = ( config >> offset ) & 0xF;
          offset += 4;
          const int edge1 = ( config >> offset ) & 0xF;
          offset += 4;
          const int edge2 = ( config >> offset ) & 0xF;
          offset += 4;
          indices.push_back( mc_vec3ui( edge_indices[ edge0 ], edge_indices[ edge1 ], edge_indices[ edge2 ] ) );
        }
      }
    }
  }
  delete[] slab_indices;
}

}  // namespace marching_cube